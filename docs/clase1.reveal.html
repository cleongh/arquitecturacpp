<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><title>Arquitectura de juegos en Unreal Engine con C++</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="clase2.reveal.18d13a9f.css"><link rel="stylesheet" href="clase2.reveal.1c90f13b.css" id="theme"><link rel="stylesheet" href="clase2.reveal.414f56ec.css"><link rel="stylesheet" href="clase2.reveal.906222cb.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Arquitectura de juegos en Unreal Engine con C++</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2> </section> <section> <section id="slide-org2b32fba"> <h2 id="org2b32fba">Profesor</h2> <ul> <li>Carlos León &lt;<a href="mailto:cleon@ucm.es">cleon@ucm.es</a>&gt;</li> <li>Profesor FdI</li> <li>Docencia MVJ: Refuerzo programación, arquitectura UE con C++, prácticas diseño de niveles, tutor de diseño</li> </ul> </section> </section> <section> <section id="slide-org0b7ce27"> <h2 id="org0b7ce27">¿Qué vamos a hacer en este módulo?</h2> <ul> <li>Vamos a ver Unreal Engine, <b>desde C++</b></li> <li>Veremos que seguimos usando el editor, Blueprints&#x2026;</li> <li>Hay mucho contenido</li> <li>Vamos a ver las partes fundamentales para que podáis seguir a partir de ahí</li> <li>Serán sesiones con algo de teoría, pero sobre todo <i>prácticas</i></li> </ul> <aside class="notes"> <ul> <li>Explicar que es material confeccionado a partir de muchos tutoriales y trozos</li> <li>que intenta ser explicativo y condensar lo básico de arquitectura C++</li> </ul> </aside> </section> <section> <p> Será, principalmente, un recorrido "en anchura" por las opciones y arquitectura que nos da UE en C++ </p> </section> </section> <section> <section id="slide-org8f9dadc"> <h2 id="org8f9dadc">Puesta en marcha</h2> </section> <section> <p> Es necesario tener instalado Visual Studio </p> <p> La versión <a href="https://www.visualstudio.com/es/vs/community/">Community</a> funciona perfectamente, aunque probablemente se pueda hacer funcionar con otras, sin mucho problema </p> </section> <section> <p> Al instalarla, aseguraos de que se instala: </p> <ul> <li>Programming Languages \(\rightarrow\) C++</li> <li>En el "Visual Studio Installer" (<code>Herramientas</code> \(\rightarrow\) <code>Obtener herramientas y características...</code>): <ul> <li><a href="https://learn.microsoft.com/en-us/visualstudio/gamedev/unreal/get-started/vs-tools-unreal-install">Desarrollo de juegos con C++</a> <ul> <li>Windows 10 SDK</li> <li>Compatibilidad con IDE para el motor de Unreal</li> <li>Visual Studio Integration Tool (bazar de la Epic Store)</li> </ul></li> </ul></li> </ul> </section> <section> <p> En macOS, <a href="https://developer.apple.com/xcode/">Xcode</a> es una alternativa válida a Visual Studio </p> <p> También se puede usar CLion y VSCode, y cualquier otro editor más simple que pueda compilar y depurar </p> <aside class="notes"> <ul> <li>Explica que UE usa compilación "normal"</li> </ul> </aside> </section> <section> <p> UE tiene su propio sistema de construcción, independiente del IDE que usemos </p> </section> <section id="slide-org228733f"> <h3 id="org228733f">Visual Studio</h3> <p> Visual Studio es <b>complejo</b>, aunque muchos ya estaréis familiarizados con él </p> </section> <section> <p> En estas clases usaremos solo la funcionalidad básica y la relación con Unreal Engine/Unreal Editor </p> <ul> <li>lanzamos el <i>Launcher</i> (de forma habitual)</li> <li>ejecutamos el editor de Unreal</li> <li>y elegimos proyecto <b>C++</b> (<b>no Blueprint</b>)</li> </ul> </section> <section> <p> Creamos un proyecto tipo <i>Basic code</i> </p> </section> <section> <div id="org306db8c" class="figure"> <p><img src="nuevo_proyecto.e570ebca.png" alt="nuevo_proyecto.png" height="500"> </p> <p><span class="figure-number">Figura 1: </span>Crear nuevo proyecto básico <b>C++</b></p> </div> </section> <section id="slide-org2d2ea3d"> <h3 id="org2d2ea3d">Unreal Editor crea un proyecto de Visual Studio</h3> <p> Ahora estaremos trabajando en paralelo con Visual Studio y Unreal Editor </p> <p> Es decir, ambas ventanas estarán abiertas, e iremos cambiando de una a otra </p> </section> <section> <p> Suele ser útil usar cada uno de los entornos para lo que hacen mejor: navegar, modificar y organizar con Unreal Editor, y programar con VS </p> <p> Pero hay mucha funcionalidad común entre UE, VS (e incluso el explorador de Windows o el cliente de versiones de código) </p> </section> </section> <section> <section id="slide-org4c920d6"> <h2 id="org4c920d6">Archivos y recursos básicos del proyecto</h2> <p> Desde el <i>punto de vista de un proyecto UE en C++</i>, los recursos imprescindible en un repositorio son: </p> <ul> <li><code>juego.uproject</code></li> <li><code>Config/</code></li> <li><code>Content/</code></li> <li><code>Source/</code></li> </ul> <p> (Puede haber muchos más archivos, pero estos son los que contienen el contenido base) </p> </section> <section> <div id="org40ceecd" class="figure"> <p><img src="regenerar_proyecto_vs.17bf512b.png" alt="regenerar_proyecto_vs.png" width="400"> </p> <p><span class="figure-number">Figura 2: </span>Unreal Engine puede re-crear los archivos de proyecto de Visual Studio a partir de un proyecto bien configurado</p> </div> </section> </section> <section> <section id="slide-orgce4de0d"> <h2 id="orgce4de0d">Arquitectura de Unreal Engine</h2> <div class="outline-text-2" id="text-orgce4de0d"> </div> </section> <section id="slide-org329b0dc"> <h3 id="org329b0dc">Unreal Engine es muy complejo</h3> <p> La arquitectura interna de Unreal, como ya habéis visto, es <b>muy grande y compleja</b> </p> </section> <section> <p> Por supuesto, no es necesario conocerla entera para poder hacer un juego en C++ en Unreal </p> <p> La arquitectura de Unreal usa mucho la herencia, pero está fundamentalmente orientada a componentes </p> </section> <section id="slide-orge449c4c"> <h3 id="orge449c4c">Un vistazo (repaso)</h3> <p> <code>Tools</code> \(\rightarrow\) <code>Class Viewer</code> </p> <div id="org7828431" class="figure"> <p><img src="actorpawn.f077dd57.svg" alt="actorpawn.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 3: </span>Actors</p> </div> </section> <section> <p> Igual que en Blueprints, <code>Actor</code> es la base de la jerarquía de los elementos en la escena de Unreal Engine (hay otras jerarquías) </p> </section> <section id="slide-orga2b04c7"> <h3 id="orga2b04c7">Nomenclatura</h3> <p> Las clases cuyo nombre empieza por <code>A</code> se refieren a objetos que pueden ser creados en el mundo. Son los actores (<code>Actor</code>) </p> </section> <section> <p> Las clases que no pueden ser creadas directamente en el mundo y tienen que pertenecer a un actor empiezan por <code>U</code> </p> </section> <section> <p> Si generamos las clases desde el editor, éste hará una buena parte del trabajo por nosotros y nombrará a los ficheros <b>sin los prefijos</b> </p> </section> <section> <p> Para declarar una clase C++ para Unreal lo hacemos de forma normal, pero añadimos un par de <i>macros</i> que informan a Unreal de la clase: <code>UCLASS</code> y <code>GENERATED_BODY()</code> </p> </section> <section id="slide-orgb93aa2f"> <h3 id="orgb93aa2f"><code>UCLASS</code></h3> <p> <code>UCLASS</code> básicamente le da al objeto C++ una referencia al objeto Unreal </p> <p> Este objeto tiene datos importantes que Unreal usa para muchas cosas </p> </section> <section> <p> Entre otras: </p> <ul> <li>recolección de basura</li> <li>serialización</li> <li>inicialización de propiedades</li> <li>integración con el editor</li> <li>replicación en red</li> <li>y <a href="https://docs.unrealengine.com/latest/en-US/objects-in-unreal-engine/">algunas otras</a></li> </ul> </section> <section id="slide-orgab68c03"> <h3 id="orgab68c03"><code>UFUNCTION</code></h3> <p> Las funciones en las clases de Unreal pueden ser métodos normales, o pueden ser <code>UFUNCTION</code> </p> </section> <section> <p> Una <code>UFUNCTION</code> puede ser usada como una función normal, pero además puede ser usada por el editor, por ejemplo en los Blueprints </p> <p> También pueden ser usadas para ser ejecutadas automáticamente por el motor, o desde la consola mientras se juega </p> </section> <section id="slide-orgf9770c2"> <h3 id="orgf9770c2"><code>USTRUCT</code></h3> <p> Un <code>USTRUCT</code> es un <code>struct</code> que se "da de alta" en Unreal Engine, <a href="https://docs.unrealengine.com/latest/en-US/structs-in-unreal-engine/">haciéndolo visible</a> para serialización, Blueprints, etc </p> </section> <section id="slide-org3951e0d"> <h3 id="org3951e0d"><code>UPROPERTY</code></h3> <p> Si creamos un componente en el constructor y queremos que Unreal se encargue de su gestión, debemos declararlo como atributo y asignarle la macro <code>UPROPERTY</code> </p> </section> <section> <p> También tenemos <code>UPARAM</code>, <code>UINTERFACE</code>&#x2026; </p> </section> </section> <section> <section id="slide-org46dd489"> <h2 id="org46dd489">Programar en Unreal con C++</h2> <p> Ahora, empecemos a programar con Unreal en C++ </p> </section> <section> <div id="orga5df7d1" class="figure"> <p><img src="crear_cubo.35d68128.png" alt="crear_cubo.png" height="500"> </p> <p><span class="figure-number">Figura 4: </span>Desde cualquier escena, creemos una malla estática (<code>Static Mesh</code>), por ejemplo un cubo</p> </div> </section> <section> <p> <code>Details</code> \(\rightarrow\) <code>Add Component</code> </p> <div id="org73a2641" class="figure"> <p><img src="crear_actor_cubo.f8eae1a0.png" alt="crear_actor_cubo.png" height="500"> </p> <p><span class="figure-number">Figura 5: </span>Añadir un <b>componente C++</b> nuevo, de tipo <code>Actor</code></p> </div> </section> <section> <p> Una vez que creamos eso, Unreal crea código y, entre el código de plantilla que crea, inserta la clase que hemos creado </p> </section> <section> <p> La podemos ver dentro de <code>Source</code>. Vayamos al <code>.h</code> </p> <p> Podemos ver también que hay unas cuantas directivas de procesador "decorando" nuestra clase </p> <p> Veremos también que, sea el nombre que sea, ha añadido una <code>U</code> al principio del nombre. Es el convenio de nombres de Unreal </p> </section> <section> <p> Si vamos al <code>.cpp</code>, es mucho más sencillo, y solo nos da dos métodos (casi) vacíos para rellenar </p> </section> <section> <p> Si volvemos al <code>.h</code>, veremos que en la parte de arriba nos deja un comentario con la cabecera del código </p> <p> En <code>Settings</code> \(\rightarrow\) <code>Project settings</code> \(\rightarrow\) <code>Description</code> podemos rellenar los campos para que nos lo genere automáticamente </p> <p> (No lo hará para archivos ya creados) </p> </section> <section> <p> En el <code>.h</code> podemos ver que nuestro componente nuevo hereda de <code>UActorComponent</code> </p> <p> Vemos que hay algunas macros (no prestemos atención a ellas ahora) y la declaración de los métodos </p> </section> <section> <p> Ya en el <code>.cpp</code> podemos ver en el constructor: </p> <div class="org-src-container"> <pre><code class="cpp">// El código se ejecutará en cada "frame"
PrimaryComponentTick.bCanEverTick = true;
</code></pre> </div> <p> En <code>BeginPlay</code>, se llama al correspondiente método del padre en la cadena de herencia (con <code>Super::BeginPlay()</code>) </p> </section> <section> <p> Nosotros vamos a escribir código en la parte que está comentada con puntos suspensivos: </p> <div class="org-src-container"> <pre><code class="cpp">// ...
</code></pre> </div> </section> <section> <p> Lo primero que vamos a hacer es usar la clase que hemos creado, el componente, para que imprima algo por pantalla, un <i>log</i> </p> </section> <section> <p> Para esto tenemos la "función": </p> <div class="org-src-container"> <pre><code class="cpp">UE_LOG(LogTemp, Warning, TEXT("Mensaje"));
</code></pre> </div> <p> (No, técnicamente no es una función&#x2026;) </p> </section> <section> <p> Por supuesto, podemos buscar la <a href="https://unrealcommunity.wiki/logging-lgpidy6i">información en Internet</a> </p> <p> <b><i>Aviso</i></b>: la calidad de la documentación del API de UE es irregular </p> </section> <section> <p> Ahora, en <code>BeginPlay</code> de nuestra nueva clase, creemos un mensaje (debajo de la llamada a <code>Super</code>): </p> <div class="org-src-container"> <pre><code class="cpp">UE_LOG(LogTemp, Warning, TEXT("¡Preparado y listo!")); 
</code></pre> </div> <ul> <li><code>LogTemp</code> es el <b>log</b> al que escribiremos</li> <li><code>Warning</code> imprime un mensaje en amarillo</li> <li><code>TEXT</code> es una macro que adapta un <code>string</code></li> </ul> </section> <section> <p> Ahora vamos a compilar nuestro proyecto: </p> <div id="org40fe657" class="figure"> <p><img src="boton_compilar.b09ed7bc.png" alt="boton_compilar.png"> </p> <p><span class="figure-number">Figura 6: </span>Botón de compilar (abajo a la derecha)</p> </div> </section> <section> <ul> <li>Podemos <i>construir la solución</i> desde Visual Studio</li> <li>O podemos guardar el archivo, volver al editor de Unreal, y compilar desde ahí</li> </ul> </section> <section> <p> (Mi experiencia es que era más robusto si se hacía desde Unreal, pero según avanzan las versiones todo parece funcionar mejor) </p> </section> <section> <ul> <li>Primero mostramos la consola de salida: <code>Window</code> \(\rightarrow\) <code>Output Log</code></li> <li>Después damos a <code>Play</code> en UE</li> <li>Deberíamos ver "¡Preparado y listo!" en el log</li> </ul> </section> </section> <section> <section id="slide-org200d3d5"> <h2 id="org200d3d5">Usando UE como código</h2> <p> Aunque veamos UE como un entorno integrado, cuando lo ejecutamos realmente estamos arrancando el <b>motor de UE</b> completo </p> </section> <section> <p> UE nos permite trabajar de forma más clásica, arrancado un IDE (VisualStudio) y compilando y depurando desde él </p> </section> <section id="slide-org66d2801"> <h3 id="org66d2801"><i>Intellisense</i></h3> <p> Veréis que el marcado de errores (el subrayado rojo) puede tardar mucho </p> <p> De hecho, a veces será incorrecto </p> <p> Pasará lo mismo con el autocompletado </p> </section> <section> <p> Esto se debe a que la base de código en enorme, y los analizadores tardan un poco </p> </section> <section> <p> En algunas ocasiones, <i>Intellisense</i> dará errores, y aún así compilará </p> <p> En algunos casos, esos errores desaparecerán incluyendo archivos de cabecera (la compilación no los necesita, pero el analizador, sí) </p> </section> <section id="slide-org80c1868"> <h3 id="org80c1868">Depurar código C++ con UE</h3> <p> Para depurar (<i>debug</i>) el código escrito en C++ hay que arrancar el editor de UE en modo depuración, desde el IDE (Visual Studio, por ejemplo) </p> </section> <section> <p> Si queremos poder depurar <i>todo el engine</i> hay que haber instalado los "Editor symbols for debugging" en UE (se puede hacer desde el Epic Launcher) </p> </section> <section> <p> Ocupan mucho, pero nos permite entrar en el código del motor para ver qué está pasando </p> <p> Obviamente, esto solo lo haremos cuando sea estrictamente necesario y cuando sepamos lo que estamos haciendo </p> </section> <section> <p> Para depurar desde VS, vamos a elegir una configuración de lanzamiento, y lanzar desde el IDE </p> </section> <section> <p> Dependiendo de la configuración que escojamos, tendremos diferentes <a href="https://docs.unrealengine.com/latest/en-US/build-configurations-reference-for-unreal-engine/">configuraciones</a>: </p> <ul> <li>Juego solo <i>desarrollo</i></li> <li>Juego + editor <i>desarrollo</i> (probablemente, ésta)</li> <li>Juego solo <i>depuración</i></li> <li>Juego + editor <i>depuración</i></li> </ul> </section> <section> <p> Yo suelo arrancar con <i>juego + editor en desarrollo</i>, con eso tengo los símbolos que necesito y puedo editar de forma normal </p> </section> <section> <p> Para otros IDEs (Clion, VSCode, Xcode), el proceso es similar </p> <p> Lo único que tenéis que tener en cuenta es saber compilar y lanzar en la configuración apropiada </p> </section> <section> <p> Una manera de trabajar alternativa a abrir UE a través del Epic Games Launcher es: </p> <ul> <li>Abrir IDE (Visual Studio)</li> <li>Arrancar la configuración de <i>editor en desarrollo</i> (que abre UE)</li> <li>Editar y depurar desde VS</li> <li>Reconstruir y ejecutar desde UE</li> </ul> </section> <section id="slide-orgaca9fe1"> <h3 id="orgaca9fe1">Live coding</h3> <p> Hasta UE5, el proceso de programa en UE con C++ sin reiniciar el juego/editor con cada cambio se hacía con una tecnología llamada <i>hot reload</i> </p> <p> Ahora (y en las últimas versiones de UE4) usamos <i>live coding</i>, está habilitado por defecto </p> </section> <section> <p> Cada vez que queramos compilar, usamos <b>Ctrl-Alt-F11</b> </p> </section> <section id="slide-org91b3a2e"> <h3 id="org91b3a2e">Visual Studio y modificaciones</h3> <div id="org0c620ac" class="figure"> <p><img src="recargar_live_coding.79b4bbbe.png" alt="recargar_live_coding.png" width="600"> </p> <p><span class="figure-number">Figura 7: </span><i>Live coding</i> funciona con casi todos los cambios de código (.cpp/.h), pero si cambiamos la estructura de clases, deberemos reiniciar el editor de UE</p> </div> </section> <section> <p> También podemos "omitir" y seguir trabajando (pero no recargará, claro) </p> </section> <section id="slide-orgc66c92e"> <h3 id="orgc66c92e">Ejecutar el proyecto sin el editor</h3> </section> <section> <p> También podemos arrancar el proyecto sin el editor </p> <div id="orgd936b89" class="figure"> <p><img src="development_config.dc4ce5d5.png" alt="development_config.png"> </p> <p><span class="figure-number">Figura 8: </span>Para eso, arrancamos con la opción <i>Development</i> (sin <i>Editor</i>)</p> </div> </section> <section> <p> Es posible que nos salga el error de que falta contenido </p> <p> Es porque no hemos "empaquetado el proyecto" </p> <div id="orgbbaa47d" class="figure"> <p><img src="empaquetar_proyecto.21884d6f.png" alt="empaquetar_proyecto.png"> </p> <p><span class="figure-number">Figura 9: </span>Volvemos al editor y empaquetamos</p> </div> </section> </section> <section> <section id="slide-org7c325d2"> <h2 id="org7c325d2">Desarrollando en UE desde C++</h2> </section> <section> <p> Ya sabéis cuál es el flujo de trabajo con <i>blueprints</i> </p> <p> A partir de aquí, vamos a ver cuál es el flujo de trabajo de generación de código con C++ </p> </section> <section> <p> Veremos que la API es muy similar, y que mucho de lo que hacemos con blueprints tiene un aspecto muy parecido en C++ </p> </section> <section> <p> Probemos la reutilización de código </p> <p> Añadamos el componente que hemos creado a otro <code>Static Mesh</code> </p> <p> <code>Details</code> \(\rightarrow\) <code>Add</code> \(\rightarrow\) buscar el componente apropiado escribiendo su nombre, y añadirlo </p> </section> <section> <p> Ahora vamos a acceder a la información de la entidad desde el componente </p> <p> Volvamos a la implementación del componente que acabamos de crear </p> <p> En la implementación, el el método <code>BeginPlay</code>, añadamos una llamada a <code>GetOwner()</code> </p> </section> <section> <p> <code>GetOwner()</code> nos da un puntero al <code>Actor</code> dentro del cual está el componente, y podemos acceder, entonces, a los métodos generales, como <code>GetName()</code> y otros </p> <p> <code>GetName()</code> nos da el nombre del <code>Actor</code> (tal como lo hayamos creado en el editor) en forma de <code>FString</code> </p> </section> <section> <p> Recordad acceder siempre a <a href="https://docs.unrealengine.com/latest/en-US/fstring-in-unreal-engine/">la documentación</a>: <code>FString</code> es una cadena mutable en Unreal </p> <div class="org-src-container"> <pre><code class="cpp">FString name = GetOwner()-&gt;GetName();
// o también
auto name = GetOwner()-&gt;GetName();
</code></pre> </div> </section> <section> <p> Pero usar un <code>FString</code> en Unreal, dentro de <code>UE_LOG</code>, no es trivial: hace falta insertarlo en la macro, usar caracteres de formato (como en <code>printf</code>) y hacer algo que <i>parece</i> una de-referencia: </p> <div class="org-src-container"> <pre><code class="cpp">FString name = GetOwner()-&gt;GetName();
UE_LOG(LogTemp, Warning, TEXT("Preparado y listo, soy %s"), *name);
</code></pre> </div> </section> <section> <p> Hay <a href="https://docs.unrealengine.com/latest/en-US/string-handling-in-unreal-engine/">varios tipos de cadenas</a> en Unreal </p> </section> <section id="slide-orgf0dd820"> <h3 id="orgf0dd820">Tipos de cadenas de texto en UE</h3> <ul> <li><code>FName</code>, ligera, almacenada en tabla, inmutable</li> <li><code>FText</code>, localización, inmutable</li> <li><code>FString</code>, mutable, no muy eficiente</li> </ul> <p> La macro <code>TEXT()</code> evita que una cadena de caracteres literal (un <i>string</i> puesto entre comillas en el código fuente) esté en <code>ANSI</code> </p> </section> <section> <p> El asterisco que hemos visto antes, realmente, es una sobrecarga particular del operador en UE </p> <p> Hace que el <code>FString</code> devuelva su <code>TCHAR</code> interno </p> </section> <section id="slide-org14330c1"> <h3 id="org14330c1">Problema</h3> <p> Dado que en Unreal se hace un uso tan extensivo de macros, si cometemos un error (fijémonos en <code>name</code>): </p> <div class="org-src-container"> <pre><code class="cpp">FString name = GetOwner()-&gt;GetName();
UE_LOG(LogTemp, Warning, TEXT("Hola, soy %s"), name);
</code></pre> </div> </section> <section> <p> Nos dará un error complejo y además informará de líneas de código que ni siquiera son nuestras (limitaciones de las macros en C++) </p> </section> <section> <p> Además de <code>name</code>, que nos dará el ID, podemos ver el nombre del objecto en el outline (su <i>label</i>, que es una propiedad solo del editor): </p> <div class="org-src-container"> <pre><code class="cpp">FString label = GetOwner()-&gt;GetActorLabel();
FString label_y_si_no_hay_name = GetOwner()-&gt;GetActorNameOrLabel();
</code></pre> </div> </section> </section> <section> <section id="slide-org6807a68"> <h2 id="org6807a68">Más información: vectores</h2> </section> <section> <p> Ahora vamos a añadir información extra sobre el objeto (en el mismo componente): </p> <div class="org-src-container"> <pre><code class="cpp">FString name = GetOwner()-&gt;GetActorLabel();
FString position { "(x, y, z)" };
UE_LOG(LogTemp,
       Warning,
       TEXT("Preparado y listo, soy %s y estoy en %s"),
       *name,
       *position); 
</code></pre> </div> </section> <section> <p> Ahora, reemplazad la cadena <code>position</code> por la posición del objeto que contiene este componente </p> <p> Recordad que VS completa código, y que el completado es <i>fuzzy</i> (no hace falta escribir la palabra exactamente en orden) </p> <p> Mirad, desde VS, qué tipo devuelve cada método para saber cómo usarlo </p> </section> <section> <p> Cuando sepáis un tipo/clase que no sepáis usar, <a href="https://docs.unrealengine.com/latest/en-US/API/Runtime/Core/Math/FTransform/">buscad en Google</a>: </p> <pre class="example" id="orgd995369">
ftransform unreal
</pre> <p> Recordad también que, una vez que obtengáis la posición, tendréis que convertirla a cadena </p> </section> <section> <p> Tiene que tener, aproximadamente, este aspecto: </p> <div class="org-src-container"> <pre><code class="cpp">FString name = GetOwner()-&gt;GetActorLabel();
FString position = GetOwner()-&gt;GetTransform().
       GetLocation().ToString();
UE_LOG(LogTemp,
       Warning,
       TEXT("Preparado y listo, soy %s y estoy en %s"),
       *name,
       *position);
</code></pre> </div> </section> <section> <p> Ahora vamos a darle un poco más de interés a lo que podemos hacer </p> <p> Creemos un cubo, y lo modificaremos, a través de un componente, desde C++ </p> </section> <section> <p> Así, </p> <ul> <li>creemos un objeto nuevo,</li> <li>añadámoslo a la escena,</li> <li>y creemos un nuevo componente en C++</li> </ul> </section> <section> <p> Luego, </p> <ul> <li>en el componente, en <code>BeginPlay</code>, cambiemos la rotación</li> <li>con un nuevo <code>FRotator</code>,</li> <li>ayudándonos con el <i>IntelliSense</i> en VS</li> </ul> </section> <section> <p> Se puede usar el constructor que se quiera, pero el más sencillo es el de <code>roll</code>, <code>pitch</code> y <code>yaw</code> </p> </section> <section> <div id="orgdbfc7a5" class="figure"> <p><img src="poner_movable.3cbb8c66.png" alt="poner_movable.png"> </p> <p><span class="figure-number">Figura 10: </span>Antes de nada, que no se nos olvide activar la propiedad <code>Movable</code> en el objeto</p> </div> </section> <section> <div class="org-src-container"> <pre><code class="cpp">GetOwner()-&gt;SetActorRotation(FRotator(34.0f, 90.0f, 0.0f));
// o también
GetOwner()-&gt;SetActorRotation({ 34.0f, 0.0f, 0.0f });
</code></pre> </div> <aside class="notes"> <p> <code>GetOwner()-&gt;GetTransform().SetRotation(f.Quaternion());</code> solía funcionar en la 4.18 creo recordar, ya no </p> </aside> </section> </section> <section> <section id="slide-org1abef8e"> <h2 id="org1abef8e">Crear y destruir elementos desde C++</h2> </section> <section> <p> Vamos a crear un <code>Actor</code> en UE, pero con una clase C++ (<b>no</b> con <i>blueprints</i>) </p> <div id="orgea0dd14" class="figure"> <p><img src="nueva_clase_actor.bdf56120.png" alt="nueva_clase_actor.png" height="450"> </p> <p><span class="figure-number">Figura 11: </span><code>Tools</code> \(\rightarrow\) <code>New C++ class...</code>, y creamos una clase de tipo <code>Actor</code></p> </div> </section> <section> <p> Después, arrastramos el nuevo actor desde el <i>Content Browser</i> hasta la escena </p> </section> <section> <p> <b>¡No ejecutéis el proyecto de momento!</b> </p> </section> <section> <p> Una vez creada la clase, vamos a crear un componente dentro de ella </p> </section> <section> <p> En el <code>.h</code>, un atributo (puede ser privado, no importa mucho ahora): </p> <div class="org-src-container"> <pre><code class="cpp">USphereComponent *_esfera;
</code></pre> </div> <p> En el <code>.cpp</code> (en el <b>constructor</b>), tras <code>bCanEverTick</code>: </p> <div class="org-src-container"> <pre><code class="cpp">_esfera = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("esfera"));
RootComponent = _esfera; // componente que da posición al actor
_esfera-&gt;InitSphereRadius(50.0f);
_esfera-&gt;SetCollisionProfileName(TEXT("Pawn"));
</code></pre> </div> </section> <section> <p> (Esto fallará) </p> <aside class="notes"> <ul> <li>explica lo que es el <code>RootComponent</code></li> </ul> <p> <a href="https://answers.unrealengine.com/questions/317148/newobject-or-createdefaultsubobject.html">createdefaultsubobject vs newobject</a>: createdefault lo ve el editor, <code>NewObject</code> no </p> </aside> </section> <section> <p> Compilamos y falla porque hemos olvidado incluir la cabecera donde está el código: </p> <div class="org-src-container"> <pre><code class="cpp">#include "Components/SphereComponent.h"
</code></pre> </div> <p> Y tiene que estar antes que: </p> <div class="org-src-container"> <pre><code class="cpp">#include "NombreDeMiActor.generated.h"
</code></pre> </div> </section> <section> <p> Sin embargo, aún no vemos nada: <i>hemos creado un objeto esfera sin malla, y no le hemos dado ningún componente malla</i> </p> </section> <section> <ol> <li>Podemos añadir el <i>Starter Content</i> si no lo tenemos aún (Content Browser \(\rightarrow\) "Add New" \(\rightarrow\) "Add Feature or Content Pack&#x2026;") (<i>aunque hay alternativa</i>)</li> <li>Añadimos más código en el constructor anterior (debajo)</li> </ol> </section> <section> <p> Con <i>Starter Content</i>: </p> <div class="org-src-container"> <pre><code class="cpp">UStaticMeshComponent *malla_esfera =
       CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(
         TEXT("malla_esfera"));
malla_esfera-&gt;SetupAttachment(RootComponent);
static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; 
       SphereVisualAsset(
         TEXT("/Game/StarterContent/Shapes/Shape_Sphere"));
malla_esfera-&gt;SetStaticMesh(SphereVisualAsset.Object);
</code></pre> </div> </section> <section> <p> También podemos añadir la esfera <b>sin</b> el <i>Starter Content</i> </p> <div class="org-src-container"> <pre><code class="cpp">static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; 
       SphereVisualAsset(
         TEXT("/Engine/BasicShapes/Sphere"));
</code></pre> </div> </section> <section> <p> Ahora podemos añadir al mapa nuestra nueva esfera creada con C++ </p> </section> <section> <p> Todo ha sido gracias a <code>ConstructorHelpers::FObjectFinder</code>: </p> <div class="org-src-container"> <pre><code class="cpp">// `static` hace que solo se cree la variable en la primera
// llamada, con lo que llamar más veces al constructor
// no lanzará una búsqueda de "asset" adicional
static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;
       SphereVisualAsset(
              TEXT("/Game/StarterContent/Shapes/Shape_Sphere"));
</code></pre> </div> </section> <section> <p> <code>static</code> aquí hace que solo haya una instancia del assets compartida por todos las =Actor=s, así <i>solo se carga la primera vez</i> </p> <p> Si no se comparte asset, igual no hace falta el <code>static</code> </p> <aside class="notes"> <p> <a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/66143-constructorhelpers-fobjectfinder-vs-static-constructorhelpers-fobjectfinder">https://forums.unrealengine.com/development-discussion/c-gameplay-programming/66143-constructorhelpers-fobjectfinder-vs-static-constructorhelpers-fobjectfinder</a> </p> </aside> </section> <section> <p> Fijémonos en que poner el código en el constructor hace que el objeto se instancie correctamente en el editor, no hace falta estar ejecutando el juego para ver la nueva esfera </p> </section> <section> <p> Si cambiamos el asset referenciado y recompilamos, UE no recargará estos assets que haya en el nivel </p> <p> Por ejemplo, si cambiamos de esfera a cono, seguiremos viendo una esfera </p> <p> <i>Será necesario volver a abrir el nivel</i> </p> </section> </section> <section> <section id="slide-org3a569eb"> <h2 id="org3a569eb">Ciclo de vida de un <code>Actor</code></h2> </section> <section> <div id="org6a6890a" class="figure"> <p><img src="ciclo_actor.9336b4f2.jpg" alt="ciclo_actor.jpg" height="500"> </p> <p><span class="figure-number">Figura 12: </span><a href="https://docs.unrealengine.com/latest/en-US/unreal-engine-actor-lifecycle/">Ciclo de vida de un actor en UE</a></p> </div> </section> <section> <p> Hay más métodos de <code>Actor</code> que pueden ser útiles (las llamadas están en orden): </p> </section> <section> <ol> <li><code>PostLoad/PostActorCreated</code> - Configurar un actor en la construcción (<code>PostLoad</code> es para serializados, <code>PostActorCreated</code> para "spawneados")</li> <li><code>AActor::OnConstruction</code> - Construcción e inicialización de los <i>blueprints</i></li> <li><code>AActor::PreInitializeComponents</code> - Llamado <i>antes</i> de <code>InitializeComponent</code> en cada uno de los componentes del <code>Actor</code></li> </ol> </section> <section> <ol> <li><code>UActorComponent::InitializeComponent</code> - Inicialización de cada componente</li> <li><code>AActor::PostInitializeComponents</code> - Llamado <i>después</i> de la inicialización de los componentes</li> <li><code>AActor::BeginPlay</code> - Llamado cuando empieza el nivel</li> </ol> </section> </section> <section> <section id="slide-org022fe03"> <h2 id="org022fe03">Spawning</h2> </section> <section> <p> Muchas veces queremos crear <i>instancias</i> de actores que ya tenemos modelados (como proyectiles) </p> <p> UE, en su clase <i>mundo</i>, nos ofrece <code>UWorld::SpawnActor</code> </p> </section> <section> <p> Pongamos esto en el <code>Tick</code> de nuestro actor C++, debajo de la llamado al <code>Tick</code> de <code>Super</code>: </p> <div class="org-src-container"> <pre><code class="cpp">FTransform spawnedTransform = GetTransform();
spawnedTransform.AddToTranslation( FVector{ 100.f, 0.f, 0.f } );
GetWorld()-&gt;SpawnActor&lt;AActor&gt;(AActor::StaticClass(),
                                    spawnedTransform);
</code></pre> </div> <p> Ejecutemos el juego, hagamos <code>Eject</code> (<code>F8</code>) y veamos cómo evoluciona la escena </p> <aside class="notes"> <ul> <li>si van bien se puede hacer con los uproperty</li> <li>cada ttr segundos tendría que spawnearse, pero no verse en la lista porque es una cutrada esto, que no se preocupen</li> </ul> </aside> </section> <section> <div id="org6cca5aa" class="figure"> <p><img src="muchos_actores.16519573.png" alt="muchos_actores.png"> </p> <p><span class="figure-number">Figura 13: </span>En ejecución podemos ver cómo se crean muchos actores</p> </div> </section> <section id="slide-org6970feb"> <h3 id="org6970feb">Destruir actores</h3> <p> En nuestro ejemplo podemos destruir, pasado un tiempo, un actor o actores </p> <p> Para destruir un actor hay que usar: </p> <div class="org-src-container"> <pre><code class="cpp">_actor-&gt;Destroy();
</code></pre> </div> <ul> <li>Hay que tener el <code>Actor</code> guardado en alguna parte</li> <li>Hay que manejar el tiempo</li> </ul> </section> <section id="slide-org1ebbf90"> <h3 id="org1ebbf90">Una solución</h3> </section> <section> <p> En el <code>.cpp</code> (en <code>Tick</code>): </p> <div class="org-src-container"> <pre><code class="cpp">if ((_counterDelete -= DeltaTime) &lt;= 0.0f) {
       _counterDelete = CD;
       for(auto &amp;a : _spawned) {
              a-&gt;Destroy();
       }
       _spawned.Empty();
}
</code></pre> </div> </section> <section> <p> Y en el <code>.h</code> (en efecto, aún no sabemos qué es un <code>TArray</code>): </p> <div class="org-src-container"> <pre><code class="cpp">private:
  TArray&lt;AActor*&gt; _spawned;
  static constexpr float CD = 5.0f;
  float _counterDelete = CD;
</code></pre> </div> </section> <section> <p> Y, para meter en el <code>TArray</code> (ahora veremos más sobre esto): </p> <div class="org-src-container"> <pre><code class="cpp">_spawned.Add(newActor);
</code></pre> </div> </section> </section> <section> <section id="slide-orgfb7112d"> <h2 id="orgfb7112d">Buscar documentación</h2> </section> <section> <p> El API de Unreal Engine es <i>enorme</i> </p> <p> Es imposible acordarse de todas las clases y métodos, es necesario trabajar siempre con la documentación a mano </p> </section> <section> <p> Desde la <a href="https://docs.unrealengine.com/latest/en-US/API/">página web del API de Unreal Engine</a> se puede acceder a toda la documentación </p> <p> Se puede buscar en la API por nombre de clase en el buscador de la página </p> <p> Y, para ver la documentación C++, hay que elegir la opcióncorrespondiente </p> <div id="org4c8d678" class="figure"> <p><img src="buscar_api.9d9e7ba5.png" alt="buscar_api.png"> </p> <p><span class="figure-number">Figura 14: </span>Elegir la información de C++ API</p> </div> </section> </section> <section> <section id="slide-org44a4155"> <h2 id="org44a4155">Ejercicios</h2> </section> <section> <ul> <li>Básico: Implementar todos los ejemplos</li> <li>Avanzado: hacer una torreta que dispare aleatoriamente a varios objetivos fijos</li> </ul> <aside class="notes"> <p> <code>FindLookAtRotation</code> </p> </aside> </section> </section> </div> </div> <script src="clase2.reveal.b569981f.js"></script> <script src="clase2.reveal.a5a6b0e0.js"></script> <script src="clase2.reveal.8f5a3bfe.js"></script> <script src="clase2.reveal.85129afe.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!0,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"none",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>