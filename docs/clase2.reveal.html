<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><title>Creación de un prototipo en Unreal con C++</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="clase1.reveal.69fcac7b.css"><link rel="stylesheet" href="clase1.reveal.2a6f2098.css" id="theme"><link rel="stylesheet" href="clase1.reveal.8448107b.css"><link rel="stylesheet" href="clase1.reveal.098a54e2.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Creación de un prototipo en Unreal con C++</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2> </section> <section> <section id="slide-org9bf1ae2"> <h2 id="org9bf1ae2">Crear juegos con Unreal en C++</h2> </section> <section> <p> Ahora que ya hemos visto todo el proceso fundamental de interacción UE con C++, vamos a crear contenido </p> </section> <section> <p> Vamos a hacer un videojuego tipo Pac-Man sencillo </p> <p> Vamos a usar assets sencillos (<i>static meshes</i>) para crear paredes de laberinto </p> <p> (Se puede usar <a href="https://docs.unrealengine.com/latest/en-US/geometry-brush-actors-in-unreal-engine/">geometría BSP</a> si queremos hacerlo más elaborado) </p> </section> <section> <p> Habrá un laberinto con puntos blancos (que nos darán una puntuación determinada) y una fruta que deberemos tocar para acabar, rodeada por una celda </p> </section> <section> <p> En nuestro juego, cuando hayamos conseguido suficientes puntos, la "celda" que rodea la fruta final se levantará y podremos coger la fruta </p> </section> <section> <p> La celda será un objeto normal físico, y la activación consistirá en que una celda suba (en la posición de la fruta) para que, cuando nos toquemos la fruta, el juego se acabe </p> </section> </section> <section> <section id="slide-org26702c6"> <h2 id="org26702c6">Nuestro Game Mode</h2> </section> <section> <p> Como ya sabéis, un <i>modo de juego</i> o <code>Game Mode</code> es el conjunto de reglas de inicio, modificación y terminación de juego (cómo se crean los jugadores, por ejemplo) </p> </section> <section> <p> Un <code>Game State</code> es el estado en el que está el juego, y es compartido por todos los clientes/jugadores </p> <p> Es dependiente del <code>Game Mode</code>, y típicamente almacena información global </p> </section> <section id="slide-org23af491"> <h3 id="org23af491">Añadir componentes al <code>DefaultPawn</code></h3> <p> Uno de los "problemas" que nos encontramos en Unreal es que, hasta que el juego no se inicia, no se crea realmente el jugador principal </p> </section> <section> <p> Como no está creado en el editor, no es posible modificar a priori sus propiedades, por ejemplo, sus <i>componentes</i> </p> </section> <section> <p> En el caso de C++, lo que vamos a hacer es asignarlo desde un <i>Game Mode</i> propio en código </p> </section> <section> <p> Por defecto, UE nos ha creado una clase que se llamará <code>A[NOMBRE]GameModeBase</code>, y que no hace nada </p> </section> <section> <p> Nosotros vamos a modificarla y añadir un constructor que establece cuál es el <i>Pawn</i> por defecto: </p> <div class="org-src-container"> <pre><code class="cpp">AMazeGameModeBase::AMazeGameModeBase()
{
  // Aún no tenemos `ACPPAdventurer`...
  DefaultPawnClass = ACPPAdventurer::StaticClass();
}
</code></pre> </div> </section> <section> <p> Lo siguiente es crear nuestro nuevo jugador principal </p> <p> Tendrá que ser un <i>Pawn</i> para que el controlador por defecto lo pueda manejar </p> </section> <section> <p> Creamos un <code>Pawn</code> normal, de C++ </p> </section> <section> <p> Ahora, desde el constructor de nuestro nuevo actor en C++, creamos algunos componentes: </p> <div class="org-src-container"> <pre><code class="cpp">ACPPAdventurer::ACPPAdventurer()
{
  PrimaryActorTick.bCanEverTick = true;

  // Damos forma para las colisiones
  auto shape = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("esfera"));
  RootComponent = shape;
  shape-&gt;InitSphereRadius(50.0f);
  shape-&gt;SetCollisionProfileName(TEXT("Pawn"));

  // Así se crea un componente para este actor
  auto move = CreateDefaultSubobject&lt;UFloatingPawnMovement&gt;(
    TEXT("Movement component"));
  move-&gt;MaxSpeed = 1200.0f;
}
</code></pre> </div> </section> <section> <p> La clase <code>UFloatingPawnMovement</code> no estará reconocida por el compilador, porque falta el <code>#include</code> </p> <div id="orgc12bcbd" class="figure"> <p><img src="includes_extra.39c562c1.png" alt="includes_extra.png" width="600"> </p> <p><span class="figure-number">Figura 1: </span>La manera más secilla es buscar la clase en Internet, y en la documentación de Unreal veremos la ruta del <code>#include</code></p> </div> </section> <section> <p> Para darle forma física al actor que acabamos de crear, le podemos poner desde C++ código para que sea un cubo </p> <p> Es igual que en la clase anterior, pero donde ponía <code>sphere</code>, tiene que poner <code>box</code> (por ejemplo) </p> </section> <section> <p> Como vamos a hacer un juego en tercera persona, creamos un <i>spring arm</i> y una cámara: </p> <div class="org-src-container"> <pre><code class="cpp">auto arm =
   CreateDefaultSubobject&lt;USpringArmComponent&gt;(
     TEXT("SpringArm"));
arm-&gt;SetupAttachment(RootComponent);

auto _camera = CreateDefaultSubobject&lt;UCameraComponent&gt;(
  TEXT("CameraPlayer"));
_camera-&gt;SetupAttachment(arm);
</code></pre> </div> </section> <section> <div id="orgec5b469" class="figure"> <p><img src="asignar_game_mode.97b8c746.png" alt="asignar_game_mode.png" height="450"> </p> <p><span class="figure-number">Figura 2: </span>También podemos crear una escena nueva, y asignarle el <code>Game Mode</code> correspondiente</p> </div> </section> </section> <section> <section id="slide-orgf67879d"> <h2 id="orgf67879d">Gestión de memoria en Unreal Engine</h2> <div class="outline-text-2" id="text-orgf67879d"> </div> </section> <section id="slide-orgbcaf2f4"> <h3 id="orgbcaf2f4"><code>UObjects</code></h3> <p> Unreal tiene su propia gestión de la memoria </p> <p> Para ello, la jerarquía de clases tiene <code>UObject</code>, que son objectos (bastante genéricos) con recolección de basura </p> </section> <section> <p> A no ser que sepamos muy bien lo que estamos haciendo, no hay que crear <code>UObjects</code> con <code>new</code>, sino con <a href="https://docs.unrealengine.com/latest/en-US/creating-objects-in-unreal-engine/">los métodos de Unreal</a>: </p> <ul> <li><code>NewObject</code></li> <li><code>SpawnActor</code></li> <li><code>CreateDefaultSubobject</code></li> </ul> </section> <section> <p> Todos estos métodos llevan el tipo como parámetro de plantilla: </p> <div class="org-src-container"> <pre><code class="cpp">auto input_modifier = NewObject&lt;UInputModifierNegate&gt;(this);
</code></pre> </div> </section> </section> <section> <section id="slide-org0bf900a"> <h2 id="org0bf900a"><i>Smart pointers</i></h2> <p> Igual que en la libería estándar de C++, Unreal tiene <a href="https://docs.unrealengine.com/latest/en-US/smart-pointers-in-unreal-engine/">punteros inteligentes</a> </p> <p> Son <code>TUniquePtr</code>, <code>TSharedPtr</code> y <code>TWeakPtr</code> (igual que en <code>std::</code>) </p> <p> <b>No tienen que ser usados para <code>UObjects</code></b>, ya que estos tienen un ciclo de vida distinto </p> </section> </section> <section> <section id="slide-org1e630fe"> <h2 id="org1e630fe">TObjectPtr</h2> <p> Unreal 5 tiene una versión más controlada de los <a href="https://unrealcommunity.wiki/pointer-types-m33pysxg">punteros a assets</a> en el editor </p> </section> <section> <p> Reemplazan los punteros "crudos" a assets, haciendo que se automatice la carga perezosa </p> <p> Además, cuando se construye en una versión que no es de editor, se optimiza </p> <p> En general, se recomienda su uso como reemplazo para <code>UPROPERTIES</code> (porque el beneficio está en el editor): </p> <div class="org-src-container"> <pre><code class="cpp">UPROPERTY(EditAnywhere)
TObjectPtr&lt;ACPPAdventurer&gt; _adventurer;
</code></pre> </div> <p> (Veremos <code>UPROPERTY</code> en un momento) </p> </section> <section> <ul> <li><code>TObjectPtr&lt;T&gt;</code> (o simplemente el punto con el <code>UPROPERTY</code>) toma posesión (quizá compartida) de un asset</li> <li><code>TWeakObjectPtr&lt;T&gt;</code> es un puntero débil sin posesión, pero tiene el coste de comprobar que el objeto no ha sido limpiado (<code>TObjectPtr</code> <i>nullifica</i> las referencias, es más eficiente)</li> <li><code>TSoftObjectPtr&lt;T&gt;</code> es como un <code>weak</code>, pero tiene funcionalidad para la carga perezosa</li> </ul> </section> <section id="slide-org8cc00fb"> <h3 id="org8cc00fb">Probando carga con TObjectPtr</h3> <p> Añadimos un <code>Actor C++</code> que tenga una propiedad de editor (<code>UPROPERTY</code>) para establecer su malla: </p> </section> <section> <p> En el <code>.h</code>: </p> <div class="org-src-container"> <pre><code class="cpp">UPROPERTY(EditAnywhere, Category = "Estetica")
TSoftObjectPtr&lt;UStaticMesh&gt; _malla_externa;

// Esto *no necesita* TSoftObjectPtr porque
// no se va a modificar en el editor
UStaticMeshComponent* _malla_component;
</code></pre> </div> </section> <section> <p> En el constructor: </p> <div class="org-src-container"> <pre><code class="cpp">ADecorador::ADecorador()
{
  // ...
  auto colision = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("esfera"));
  RootComponent = colision;
  colision-&gt;InitSphereRadius(50.0f);
  colision-&gt;SetCollisionProfileName(TEXT("Pawn"));

  _malla_component =
    CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(
        TEXT("malla"));
  _malla_component-&gt;SetupAttachment(RootComponent);
}
</code></pre> </div> </section> <section> <p> En <code>BeginPlay</code>: </p> <div class="org-src-container"> <pre><code class="cpp">void ADecorador::BeginPlay()
{
  // ...
  _malla_component-&gt;SetStaticMesh(_malla_externa.LoadSynchronous());	
}
</code></pre> </div> </section> <section> <p> Añadimos una instancia a la escena, asignamos su malla, y se verá instanciada al darle a <code>Play</code> </p> </section> </section> <section> <section id="slide-org2cc354a"> <h2 id="org2cc354a">Entrada con <code>Enhanced Input</code></h2> <div class="outline-text-2" id="text-org2cc354a"> </div> </section> <section id="slide-org3e1895b"> <h3 id="org3e1895b">Entrada hasta UE4</h3> <p> UE4 usa un motor de entrada más sencillo que UE \(\geq 5\) </p> </section> <section id="slide-orgafd4abe"> <h3 id="orgafd4abe">Enhanced Input</h3> <p> Para que UE reconozca el subsistema de entrada nuevo, hay que asegurarse de que la cadena <code>"EnhancedInput"</code> está en el archivo <code>[NOMBRE_PROYECTO].Build.cs</code>, que estará en el mismo sitio que los <code>.cpp</code>: </p> <div class="org-src-container"> <pre><code class="csharp">PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });
</code></pre> </div> </section> <section> <p> En versiones recientes, esto ya estará añadido al crear el proyecto. </p> </section> <section> <div id="org2672331" class="figure"> <p><img src="configurar_enhanced_input.6cd998af.png" alt="configurar_enhanced_input.png" height="300"> </p> <p><span class="figure-number">Figura 3: </span>Tenemos que asegurarnos (seguramente estará así por defecto) de que el subsistema mejorado está seleccionado por defecto</p> </div> </section> <section> <p> En la declaración de la clase de nuestro personaje (el <code>.h</code>), creamos punteros a las clases de Enhanced Input que antes hacíamos con Blueprints: </p> <div class="org-src-container"> <pre><code class="cpp">#include "InputMappingContext.h"
#include "EnhancedInputComponent.h"
// ...

// El mapping context
UInputMappingContext* _input_mapping_context;

// Una acción (puede haber más)
UInputAction* _move;
</code></pre> </div> </section> <section> <p> En el constructor, las instanciamos: </p> <div class="org-src-container"> <pre><code class="cpp">_move = CreateDefaultSubobject&lt;UInputAction&gt;(TEXT("MoveAction"));

_input_mapping_context = CreateDefaultSubobject&lt;UInputMappingContext&gt;(TEXT("NormalMapping"));	
</code></pre> </div> </section> <section> <p> En en <code>.cpp</code> de nuestro <code>Pawn</code> vamos a configurar la entrada para que enlace los mappings y las acciones: </p> <div class="org-src-container"> <pre><code class="cpp">#include "EnhancedInputSubsystems.h"
#include "Engine/LocalPlayer.h" 
// ...
void ACPPAdventurer::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
        Super::SetupPlayerInputComponent(PlayerInputComponent);

        auto controller = Cast&lt;APlayerController&gt;(GetController());
        if (auto system = controller-&gt;GetLocalPlayer()-&gt;GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;()) {
                if (_input_mapping_context) {
                        // el "1" es la prioridad del mapeo, cuanto más alta, más prioritario
                        system-&gt;AddMappingContext(_input_mapping_context, 1);

                        _move-&gt;bConsumeInput = true;
                        _move-&gt;ValueType = EInputActionValueType::Axis1D;

                        // hay más maneras de instanciar la tecla (FKey("W"))
                        _input_mapping_context-&gt;MapKey(_move, EKeys::W);

                        auto &amp; mapping = _input_mapping_context-&gt;MapKey(_move, EKeys::S);
                        mapping.Modifiers.Add(NewObject&lt;UInputModifierNegate&gt;(this));
                }
        }

        auto eic = Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent);
        eic-&gt;BindAction(_move, ETriggerEvent::Triggered, this, &amp;ACPPAdventurer::Move);
}
</code></pre> </div> </section> <section> <p> Y el método <code>Move</code> (que está en la clase como un método normal), usa el valor del eje para mover el <code>Actor</code> </p> <div class="org-src-container"> <pre><code class="cpp">void ACPPAdventurer::Move(const FInputActionValue&amp; v) {	
        FVector forward = GetWorld()-&gt;
                GetFirstPlayerController()-&gt;
                PlayerCameraManager-&gt;
                GetCameraRotation().Vector();
        AddMovementInput(forward, v.GetMagnitude());
}
</code></pre> </div> </section> <section> <p> Con esto ya podemos hacer los movimientos en 4 direcciones o, mejor aún, que el personaje rote cuando usamos <i>izquierda</i> o <i>derecha</i> </p> </section> <section> <p> Buscad cómo rotar en la ayuda de UE </p> <p> Haremos otro <code>BindAction()</code> para la rotación </p> <p> Y moveremos la rotación del personaje </p> </section> <section> <p> Los <code>FRotator</code> se pueden sumar con el operador <code>+</code> (está sobrecargado) </p> </section> </section> <section> <section id="slide-org2139926"> <h2 id="org2139926">Propiedades para el editor</h2> </section> <section> <p> Una de las macros más usadas es <code>UPROPERTY</code> </p> <p> <code>UPROPERTY</code> se usa para hacer que ciertos atributos de nuestro código (atributos de clase) se <i>expongan</i> al editor y puedan ser gestionados gráficamente </p> </section> <section> <p> Por ejemplo, podemos configurar la altura de la celda que rodea a la fruta con esta técnica </p> </section> <section> <p> Creamos un Actor para la celda (como <i>blueprint</i>) </p> <div id="orgb4d4c88" class="figure"> <p><img src="celda.20d1fa26.png" alt="celda.png" height="500"> </p> <p><span class="figure-number">Figura 4: </span>Se puede hacer la celda con varios <code>Cube</code> en el blueprint</p> </div> </section> <section> <p> Y creamos un componente en C++ para la celda </p> <p> Vamos a nuestro componente de subir la celda y creamos un atributo de altura final que tendrá cuando tengamos todos los puntos: </p> <div class="org-src-container"> <pre><code class="cpp">private:
    double _height = 90.0f;
</code></pre> </div> </section> <section> <p> Para que ese atributo tenga uso en el editor, tenemos que <i>marcarlo</i> como propiedad de Unreal </p> <p> <code>URPOPERTY</code> es para eso: </p> <div class="org-src-container"> <pre><code class="cpp">private:
    UPROPERTY(VisibleAnywhere)
    double _height = 90.0f;
</code></pre> </div> </section> <section> <p> <b>Importante</b> </p> <p> Como ya dijimos, no olvidemos hacer la entidad <code>Movable</code> para que sus propiedades físicas se puedan cambiar durante la ejecución </p> <div id="org9455c84" class="figure"> <p><img src="celda_movable.11f92820.png" alt="celda_movable.png" height="200"> </p> <p><span class="figure-number">Figura 5: </span>Hacer un objeto <code>Movable</code></p> </div> </section> <section> <p> Podemos hacer propiedades de varios tipos </p> <p> Por ejemplo, una propiedad de cadena de texto nueva, esta vez que <b>se pueda editar desde cualquier parte del editor de Unreal</b> </p> </section> <section> <p> Será algo parecido a esto (atención a <code>EditAnywhere</code>): </p> <div class="org-src-container"> <pre><code class="cpp">private:
    UPROPERTY(EditAnywhere)
    FString _text;
</code></pre> </div> </section> <section> <p> Para que aparezca un <i>tool tip</i> cuando pasamos el cursor por una propiedad: </p> <div class="org-src-container"> <pre><code class="cpp">private:
    // Un cometario encima es interpretado como documentación
    UPROPERTY(EditAnywhere)
    FString _text1;

    UPROPERTY(EditAnywhere, meta=(ToolTip="Con argumentos también"))
    FString _text2;
</code></pre> </div> <p> La versión con <code>meta</code> tiene prioridad sobre el comentario </p> </section> <section> <p> Se pueden hacer categorías y subcategorías: </p> <div class="org-src-container"> <pre><code class="cpp">UPROPERTY(EditAnywhere, Category = "Estetica|Mallas")
</code></pre> </div> </section> <section> <p> Podéis encontrar los muchos parámetros que se pueden poner en la documentación de las <a href="https://docs.unrealengine.com/latest/en-US/unreal-engine-uproperties/">propiedades</a> y los <a href="https://docs.unrealengine.com/latest/en-US/metadata-specifiers-in-unreal-engine/">metadatos</a> </p> </section> <section id="slide-orgdd730cd"> <h3 id="orgdd730cd">Relaciones entre entidades</h3> <p> Hay una relación de dependencia entre nuestro personaje principal y nuestra celda </p> <p> Necesitamos una manera de decirle a la celda con qué <code>Actor</code> tiene que interactuar </p> </section> <section> <p> Crearemos una <code>UPROPERTY(EditAnywhere)</code> en el componente de subida que sea de tipo <code>ACPPAdventurer</code> </p> </section> <section> <p> Idealmente, estamos creando un componente genérico que permita trabajar con cualquier <code>ACPPAdventurer</code> </p> <p> Pero <i>nuestro héroe se crea en tiempo de ejecución, no antes</i> </p> </section> </section> <section> <section id="slide-orgfbdc366"> <h2 id="orgfbdc366">Accediendo a distintas entidades desde C++</h2> </section> <section> <p> En Unreal, los cuerpos físicos son <code>Pawn</code>, y son movidos por controladores </p> <p> En este caso, por un <code>PlayerController</code> </p> <p> La idea es que, desde el punto de vista de la arquitectura, el controlador pueda ser sustituido, y un mismo <code>Pawn</code> pueda ser manejado a través de diferentes controladores </p> </section> <section> <p> Hay varias alternativas para arquitecturas de componentes </p> <p> En las más puras, los componentes no hablan entre sí directamente, y no pueden interactuar </p> <p> (Por ejemplo, las arquitecturas de paso de mensajes) </p> </section> <section> <p> Hasta ahora habíamos trabajado con acceso desde <i>abajo</i> hasta <i>arriba</i>, de forma que, con <code>GetOwner()</code>, habíamos tenido acceso a la entidad contenedora </p> <p> Pero es muy útil poder acceder de arriba a abajo, es decir, desde la entidad superior, a la entidad que está incluida en ella </p> </section> <section id="slide-orgb1bbc02"> <h3 id="orgb1bbc02"><code>GetWorld</code></h3> <p> <code>GetWorld</code> nos da acceso a todo el mundo </p> <p> Todos los juegos en Unreal, por defecto, tienen un controlador principal </p> <p> Este controlador es parte del mundo, así que, desde el mundo, podemos acceder a él con <code>GetFirstPlayerController()</code> </p> </section> <section> <p> Cuando un escenario arranca en Unreal, por defecto, el controlador es asignado a un jugador, a un <code>Pawn</code> </p> <p> Por tanto, podemos acceder a ese <code>Pawn</code>: </p> <div class="org-src-container"> <pre><code class="cpp">APawn * pawn = 
  GetWorld()-&gt;GetFirstPlayerController()-&gt;
    GetPawn();
</code></pre> </div> </section> <section> <p> Por lo tanto, vamos a hacer que, <i>cuando se arranque el juego</i>, nuestra celda enlace la propiedad del componente de subida al jugador principal </p> <p> Lo haremos en el <code>BeginPlay()</code> del componente de bajada, aunque estemos creando por ahora una dependencia incorrecta </p> <p> (Recordad <code>GetWorld()-&gt;GetFirstPlayerController()-&gt;GetPawn()</code>) </p> </section> <section> <p> Nos pasará que <code>GetPawn</code> nos devuelve un <code>Pawn</code> y no un <code>CPPAdventurer</code> </p> <p> Pero podemos hacer <i>casting</i> </p> </section> <section> <div class="org-src-container"> <pre><code class="cpp">auto *pawn = GetWorld()-&gt;
    GetFirstPlayerController()-&gt;
    GetPawn();

// puede devolver `nullptr` si el casting falla
_adventurer = Cast&lt;ACPPAdventurer&gt;(pawn); 
</code></pre> </div> </section> <section> <p> Así, vamos a hacer que en el <code>TickComponent</code> apropiado (es decir, en cada frame del juego, en el componente): </p> <ul> <li>cuente los puntos del héroe</li> <li>y, si tiene más puntos que un umbral dado (¡hacemos un <code>UPROPERTY</code>!), la celda se eleve</li> </ul> </section> <section id="slide-org353bbe8"> <h3 id="org353bbe8"><code>FindComponentByClass</code></h3> <p> Aunque en Unreal se pueden hacer muchas alternativas, es bastante común que un componente de la entidad quiera acceder a otro componente de la misma entidad </p> <p> Para eso tenemos el método <code>FindComponentByClass</code>: </p> <div class="org-src-container"> <pre><code class="cpp">[UClaseDelComponente] componentHandle =
    GetOwner()-&gt;FindComponentByClass&lt;UClaseDelComponente&gt;();
</code></pre> </div> </section> </section> <section> <section id="slide-orgb149861"> <h2 id="orgb149861">Ojo con los <code>colliders</code></h2> </section> <section> <p> Tanto los <code>Collider</code> como los <code>Trigger</code> detectan contactos, pero los <code>Collider</code> tienen en cuenta la física </p> <p> Para que algo en Unreal tenga entidad física (colisiones físicas, por ejemplo), tenemos que cambiar sus propiedades de colisión </p> </section> <section> <p> Las físicas en Unreal son muy complejas (¡y potentes!), nosotros vamos a centrarnos en los aspectos básicos aquí </p> </section> <section> <p> Es muy posible (por ejemplo, la fruta) que no tenga ninguna información sobre colisión, así que tendremos que crearla </p> <p> (Aunque si lo habéis hecho paso a paso, debería tener una malla de colisión por defecto) </p> </section> <section> <p> En el menú <code>Collision</code> podemos añadirle una colisión. Recordemos que estaremos <b>editando la malla</b>, con lo que todos los objetos que usen esa malla tendrán información de <i>colliders</i> </p> </section> <section> <ol> <li>Hacemos clic derecho sobre la barrera o en el <i>World Outliner</i></li> <li>Elegimos "Edit [Nombre de la barrera]"</li> <li><code>Collision</code> \(\rightarrow\) <code>Add Box Simplified Collision</code> (por ejemplo)</li> </ol> </section> <section> <p> Ahora ya tenemos <i>un pequeño juego</i> </p> <p> Hay un desafío, y hay que seguir las reglas preestablecidas para solucionarlo </p> </section> </section> <section> <section id="slide-orgecb7107"> <h2 id="orgecb7107">TArray</h2> </section> <section> <p> Como ya vimos, Unreal usa su propia estructura de <i>array</i>: <a href="https://docs.unrealengine.com/latest/en-US/API/Runtime/Core/Containers/TArray/"><code>TArray</code></a> </p> <p> Es una estructura con genéricos (igual que <a href="http://www.cplusplus.com/reference/vector/vector/"><code>vector</code></a> en STL) </p> </section> <section> <p> Imaginemos que queremos saber, por ejemplo, cuántos puntos tenemos, almacenando los valores de cada punto que toquemos </p> </section> <section> <p> Además, <code>TArray</code> implementa los <a href="http://www.cprogramming.com/c++11/c++11-ranged-for-loop.html">métodos apropiados de C++11</a> para ser usado con la sintaxis moderna de <code>for</code>: </p> <div class="org-src-container"> <pre><code class="cpp">TArray &lt;int&gt; arrayDePuntos;
for(int a : arrayDePuntos) {
    a-&gt;...
}
</code></pre> </div> </section> <section> <p> Vamos, en nuestro héroe, a tener un <code>TArray</code> de enteros (un atributo de la clase) </p> <p> Cada elemento serán los puntos que dé cada punto blanco que nos hemos "comido" </p> <p> Tendremos métodos para sumar puntos (por parámetro) y un método para devolver los puntos actuales </p> </section> <section id="slide-orga8c66fc"> <h3 id="orga8c66fc">Comer puntos</h3> <p> Falta hacer la lógica de las "gemas" </p> <p> Van a ser actores que tengan un componente con un <code>UPROPERTY</code> de tipo entero que almacene los puntos que da cada instancia </p> </section> <section> <p> Cuando despleguemos gemas por el mapa, vamos a ir, uno a uno, estableciendo los puntos que otorga cada una </p> <p> Obviamente se puede poner un valor por defecto en la clase de las gemas, y luego modificarlo si se quiere </p> </section> <section> <p> En la celda pondremos un <code>UPROPERTY</code> con los puntos totales que son necesarios para subirla </p> <p> El componente de subir la celda, en su <code>TickComponent</code>, comprobará si los puntos totales del actor superan los de la propiedad anterior </p> </section> <section> <p> Para que el personaje no choque con los elementos no físicos, hay que cambiar las propiedades </p> <p> Para que las cosas solapen (es decir, <b>no colisionen</b>), es mejor cambiar las propiedades físicas a <code>OverlapAll</code> </p> <div id="orgd1b999f" class="figure"> <p><img src="overlap_all.b7056804.png" alt="overlap_all.png" height="200"> </p> <p><span class="figure-number">Figura 6: </span>En el <i>blueprint</i> de las gemas, en la esfera que tienen, establecemos "overlap"</p> </div> </section> <section> <p> Para asignar los puntos al jugador, vamos a hacer, desde el componente de los puntos, que cuando se haga <i>overlap</i> con el jugador, se le sumen los puntos </p> </section> <section> <p> Detectar <i>overlapping</i> sólo hay que llamar al método: </p> <div class="org-src-container"> <pre><code class="cpp">actor-&gt;IsOverlappingActor(otroActor) // booleano
</code></pre> </div> </section> <section> <p> También haremos que la gema se destruya con <code>Destroy()</code> </p> <div class="org-src-container"> <pre><code class="cpp">// Dentro del componente que detecta overlap con el jugador
GetOwner()-&gt;Destroy();
</code></pre> </div> </section> <section> <p> Y, una vez que sabemos hacer el "overlap", usamos el mismo método con la fruta para terminar el juego </p> </section> <section> <p> Necesitaremos que la gema (y la fruta) tengan una referencia al jugador principal, igual que la celda </p> </section> </section> <section> <section id="slide-org7b63905"> <h2 id="org7b63905">Para acabar</h2> </section> <section> <p> Una vez que solapen actor y fruta, vamos a pasar de escena </p> </section> <section> <p> Para ello, simplemente creamos un nuevo componente C++ para la fruta, y en su <code>TickComponent</code>: </p> <div class="org-src-container"> <pre><code class="cpp">// si
GetOwner()-&gt;IsOverlappingActor(/* player */)

// entonces
UGameplayStatics::OpenLevel(this, TEXT("Fin"));
</code></pre> </div> </section> </section> <section> <section id="slide-orgca1fa99"> <h2 id="orgca1fa99">Ejercicios</h2> <ul> <li>Implementar la mecánica básica del juego <ul> <li>No hemos contado cómo hacer la rotación, pero es igual que el avance</li> </ul></li> <li>Mejorar el <i>gameplay</i> haciendo que los giros del protagonista sean más suaves</li> <li>Colocar mejor la cámara</li> </ul> </section> </section> </div> </div> <script src="clase1.reveal.372e8951.js"></script> <script src="clase1.reveal.e41122ab.js"></script> <script src="clase1.reveal.a11129a9.js"></script> <script src="clase1.reveal.167eb7a6.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!0,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"none",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>