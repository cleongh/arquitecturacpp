<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><title>Trabajar con blueprints visuales y C++</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="/clase1.reveal.69fcac7b.css"><link rel="stylesheet" href="/clase1.reveal.2a6f2098.css" id="theme"><link rel="stylesheet" href="/clase1.reveal.8448107b.css"><link rel="stylesheet" href="/clase1.reveal.098a54e2.css"></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Trabajar con blueprints visuales y C++</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2> </section> <section> <section id="slide-orgdb1c06b"> <h2 id="orgdb1c06b">¿BP o C++?</h2> <div class="outline-text-2" id="text-orgdb1c06b"> </div> </section> <section id="slide-orgc3daf4f"> <h3 id="orgc3daf4f">¿Por qué usar Blueprint visuales?</h3> </section> <section> <p> En C++ es más sencillo (y en ocasiones más eficiente) hacer ciertos comportamientos (como cálculos matemáticos complejos) </p> </section> <section> <p> Sin embargo, hay algunos comportamientos que se programan muy fácilmente de modo gráfico </p> </section> <section id="slide-org93b5f2d"> <h3 id="org93b5f2d">Componentes como bloques Blueprint visuales</h3> </section> <section> <p> Vamos a crear un actor+componente que sea un trigger y se active justo delante de la celda, sólo si tenemos los puntos suficientes </p> <p> El <code>Actor</code> puede ser en Blueprints o en C++ </p> </section> <section> <p> Cuando solape con ese actor, lanzará un evento </p> </section> <section> <p> Ahora, <i>en el componente</i>, añadimos (por encima de <code>UCLASS(ClassGroup</code>&#x2026;))=) el siguiente código: </p> <div class="org-src-container"> <pre><code class="cpp">DECLARE_DYNAMIC_MULTICAST_DELEGATE()
</code></pre> </div> </section> <section> <p> Un <a href="https://docs.unrealengine.com/latest/en-US/delegates-and-lamba-functions-in-unreal-engine/"><i>delegate</i></a> es una estructura que encapsula una llamada a función </p> <p> Se usan para conectar <i>blueprints</i> con C++ </p> </section> <section> <p> <code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code> es necesario si queremos que haya una propiedad del componente que podamos asignar en un Blueprint </p> <ul> <li><code>DYNAMIC</code>: puede ser serializado</li> <li><code>MULTICAST</code>: de uno a muchos</li> <li><code>DELEGATE</code>: algo externo va a manejar la operación</li> </ul> </section> <section> <p> Ahora creamos el código: </p> <div class="org-src-container"> <pre><code class="cpp">// hay muchas macros en las que ';' es opcional
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FAntesTerminar); 
</code></pre> </div> <p> (Recordemos que <code>F</code> al principio de la clase se usa por convenio en Unreal) </p> <p> Esto crea una clase propia para la señal en el editor de Blueprints </p> </section> <section> <p> Después, en los atributos privados, creemos un <code>UPROPERTY</code> con el param de esa clase que hemos referenciado en <code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code> </p> </section> <section> <p> Esta propiedad tiene que ser <code>BlueprintAssignable</code>: <a href="https://docs.unrealengine.com/latest/en-US/exposing-gameplay-elements-to-blueprints-visual-scripting-in-unreal-engine/"><code>UPROPERTY(BlueprintAssignable)</code></a> para que se vea en el editor: </p> <div class="org-src-container"> <pre><code class="cpp">UPROPERTY(BlueprintAssignable)
FAntesTerminar AntesTerminar;
</code></pre> </div> </section> <section> <p> Bien, ahora hemos creado un <i>evento</i> </p> </section> <section> <p> Para ello, cuando detectemos solape con la gema, vamos a hacer <code>Broadcast</code> sobre el evento: </p> <div class="org-src-container"> <pre><code class="cpp">AntesTerminar.Broadcast();
</code></pre> </div> </section> <section> <p> Si hemos hecho el actor en C++ tenemos que añadir el componente al actor de nuestro trigger con <code>CreateDefaultSubobject</code> </p> <p> Si está en Blueprint, directamente en el editor </p> <p> Añadimos también, en el <code>Actor</code>, un <code>Box</code> de colisión para establecer el volumen </p> </section> <section> <p> Si el <code>Actor</code> está en C++, el componente tendrá que ser <code>BlueprintReadWrite</code> porque queremos acceder a él desde el editor de <i>blueprints</i>: </p> <div class="org-src-container"> <pre><code class="cpp">public:
  UPROPERTY(EditAnywhere, BlueprintReadWrite)
  UComponenteAntesTerminar * _antesTerminar;
</code></pre> </div> <aside class="notes"> <p> Tenía puesto que tenía que ser "public" en la clase, pero no lo tengo muy claro </p> </aside> </section> <section> <p> Ahora vamos al Blueprint del actor que contiene el componente y en los eventos añadimos el nuevo evento que ha aparecido: </p> <div id="org9387a00" class="figure"> <p><img src="/evento_aparece_en_bp.d99baa57.png" alt="evento_aparece_en_bp.png" height="450"> </p> <p><span class="figure-number">Figura 1: </span>Aparecerá un botón nuevo en los eventos, pinchando en el componente</p> </div> </section> <section> <div id="org21eebdc" class="figure"> <p><img src="/usar_delegate_bp.e3a1466b.png" alt="usar_delegate_bp.png" height="500"> </p> <p><span class="figure-number">Figura 2: </span>Y este evento lo podemos usar en el <i>blueprint</i> como queramos</p> </div> </section> </section> <section> <section id="slide-org97b85c2"> <h2 id="org97b85c2">Funciones desde C++</h2> </section> <section> <p> Hasta ahora nos hemos centrado en usar C++ como una alternativa a <i>blueprints</i>, pero realmente se complementan muy bien </p> </section> <section> <p> Vamos a ver cómo llamar a funciones C++ desde <i>blueprints</i>, y a funciones <i>blueprint</i> desde C++ </p> </section> </section> <section> <section id="slide-org3559163"> <h2 id="org3559163">Llamar a funciones desde el editor</h2> </section> <section> <p> En el <code>.h</code> de un <code>Actor</code> nuevo, añadimos el prototipo de una función sencilla: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
void SaySomething(const FText &amp; text);
</code></pre> </div> </section> <section> <p> Que implementamos así: </p> <div class="org-src-container"> <pre><code class="cpp">void AActorFuncionLlamable::SaySomething(const FText &amp;text)
{
    FString str = text.ToString();
    UE_LOG(LogTemp, Warning, TEXT("%s"), *str)
}
</code></pre> </div> <aside class="notes"> <p> Puedes recordarles que <code>FText</code> es lo suyo para cadenas localizadas </p> </aside> </section> <section> <p> Las <code>UFUNCTION</code> usan los parámetros como entrada, a no ser que sean como referencia no constante, caso en el cual los usan como salida: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
int32 fun(int32 &amp; output);
</code></pre> </div> </section> <section> <p> Para hacer que esos parámetros no sean de salida, usamos la macro <code>UPARAM</code>, con el argumento <code>ref</code> </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
int32 fun(
    UPARAM(ref) int32 &amp; output
    );
</code></pre> </div> </section> <section> <p> También podemos cambiar la etiqueta de la variable: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
int32 fun(
    UPARAM(DisplayName="Total weight") int32 &amp; output
    );
</code></pre> </div> </section> <section> <p> Para alimentar la función, podemos construir el siguiente esquema en el <i>blueprint</i> del nivel: </p> <div id="orgb6a4fd7" class="figure"> <p><img src="/bp_llama_cpp.be85b376.png" alt="bp_llama_cpp.png" height="450"> </p> <p><span class="figure-number">Figura 3: </span>Blueprint para establecer variable</p> </div> </section> <section> <p> Podemos establecer diferentes tipos de <code>UFUNCTION</code>, de forma que si queremos una función constante/pura (sin "pestañas" de orden de ejecución en los <i>blueprints</i>, porque no tiene <i>side-effects</i>): </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
float CalculoSinEfectos() const;
</code></pre> </div> </section> </section> <section> <section id="slide-orgac72600"> <h2 id="orgac72600">Llamar a funciones <i>blueprint</i> desde C++</h2> </section> <section> <p> <a href="https://docs.unrealengine.com/latest/en-US/API/Runtime/CoreUObject/UObject/UObject/CallFunctionByNameWithArguments/"><code>UObject</code></a> tiene el método <code>CallFunctionByNameWithArguments</code> </p> <p> Con este método podemos acceder a una función en <i>blueprints</i> </p> </section> <section> <p> Vamos a crear un componente <i>blueprint</i> en el editor (es decir, <b>que no sea C++</b>) </p> <p> En él, creamos una función que imprima un texto por pantalla </p> </section> <section> <div id="org1303617" class="figure"> <p><img src="/funcion_bp_llamable.f2f117b7.png" alt="funcion_bp_llamable.png" height="450"> </p> <p><span class="figure-number">Figura 4: </span>Función con un parámetro <code>Text</code> que imprime la entrada</p> </div> </section> <section> <p> Ahora creamos un <code>Actor</code> en C++, y en algún sitio (<code>Tick</code>, <code>BeginPlay</code>): </p> <div class="org-src-container"> <pre><code class="cpp">#include "Misc/OutputDeviceNull.h"

// UImprimidorPadreCPP no existe aún
auto f = FindComponentByClass&lt;UImprimidorPadreCPP&gt;();
if (nullptr != f)
{
    // puede ser este null ahora
    FOutputDeviceNull n;

    f-&gt;CallFunctionByNameWithArguments(
        TEXT("Saludar \"hola a todos\""),
        n,  // dispositivo de salida
        nullptr, // ejecutor (null vale)
        true); // forzar llamada (T vale)
}
</code></pre> </div> </section> <section> <p> En efecto, <i>no compila</i> </p> </section> <section> <p> Lo que ocurre es que necesitamos que la clase a la que estamos haciendo referencia <i>exista en C++</i> </p> </section> <section> <p> Vamos a crear una nueva clase en C++ que sea <i>padre</i> de la clase que queremos, para así poder importarla (<code>#include</code>) </p> </section> <section> <p> Creamos una clase <code>Actor</code> de C++ </p> <p> Nos aseguramos de que su <code>UCLASS</code> sea <code>Blueprintable</code> </p> </section> <section> <div class="org-src-container"> <pre><code class="cpp">UCLASS( Blueprintable, ...)
</code></pre> </div> </section> <section> <p> Asegurémonos de que todo compila correctamente </p> </section> <section> <p> Ahora volvemos a nuestra clase <i>blueprint</i> original, y cambiamos el padre: </p> <div id="org7fda5da" class="figure"> <p><img src="/reparent_class.1c6c684e.png" alt="reparent_class.png" height="350"> </p> <p><span class="figure-number">Figura 5: </span>Cambiar el padre de una clase</p> </div> </section> <section> <p> Ahora ya podemos <i>incluir</i> la clase <b>padre</b> en nuestro <code>ActorQueLlamaBP</code> </p> <div class="org-src-container"> <pre><code class="cpp">#include "ImprimidorPadreCPP.h"
</code></pre> </div> <aside class="notes"> <p> recálcales que es la <b>clase padre</b> sólo, pero que eso funciona porque la llamada no necesita tipos </p> </aside> </section> <section> <p> Y probamos: </p> <div class="org-src-container"> <pre><code class="cpp">#include "Misc/OutputDeviceNull.h"

// Si el BP se llama 'UImprimidorPadreCPP', y la función "Saludar"
auto f = FindComponentByClass&lt;UImprimidorPadreCPP&gt;();
if (nullptr != f) // comprobad siempre
  {
    FOutputDeviceNull n;
    FString param = "\"hola a todos!\" 6";
    FString cmd =
      FString::Printf(
		      TEXT("Saludar %s"),
		      *param);

    // Debe imprimir "hola a todos!" y "7" en pantalla
    f-&gt;CallFunctionByNameWithArguments(
       *cmd, n, nullptr, true);
  }
</code></pre> </div> </section> <section> <div id="orgd337975" class="figure"> <p><img src="/salida_bp_desde_cpp.7553f5fb.png" alt="salida_bp_desde_cpp.png" height="400"> </p> <p><span class="figure-number">Figura 6: </span>Ejemplo de salida llamado a una función <i>blueprint</i> desde C++</p> </div> </section> </section> <section> <section id="slide-org1a52236"> <h2 id="org1a52236">Más maneras de interactuar BP/C++</h2> <div class="outline-text-2" id="text-org1a52236"> </div> </section> <section id="slide-org0854f6b"> <h3 id="org0854f6b"><code>BlueprintImplementableEvent</code></h3> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintImplementableEvent)
void EventoBP();
</code></pre> </div> </section> <section id="slide-orgaf7898d"> <h3 id="orgaf7898d"><code>BlueprintNativeEvent</code></h3> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintNativeEvent)
void EventoBP();

// ...

void AMiActor::EventoBP_Implementation()
{
  // ...
}
</code></pre> </div> </section> </section> <section> <section id="slide-org3cfdb8b"> <h2 id="org3cfdb8b">Cosas que los <i>blueprints</i> no pueden hacer</h2> </section> <section> <p> Se puede llegar muy lejos con <i>blueprints</i> </p> <p> Pero hay algunas cosas que necesitan C++ </p> </section> <section id="slide-org2799259"> <h3 id="org2799259">Importar librerías externas</h3> <p> Para código existente (en C++ u otros lenguajes), hay que usar C++ </p> </section> <section id="slide-org9c52cce"> <h3 id="org9c52cce">Colaborar a nivel de módulo</h3> <p> Los <i>blueprints</i> son archivos binarios, es difícil ponerlos en control de versiones y trabajar por partes en paralelo </p> </section> <section id="slide-org9d347b7"> <h3 id="org9d347b7">Algunas cosas se expresan mejor en C++</h3> <p> Los <i>blueprints</i> están pensado para lógica de juego, no para algoritmos complejos y genéricos </p> <p> Muchas veces, el código C++ será más fácil de mantener que un script visual de <i>blueprints</i> muy complejo </p> </section> </section> <section> <section id="slide-orge9ba94e"> <h2 id="orge9ba94e">Eficiencia <i>blueprints</i> y eficiencia C++</h2> <blockquote> <p> Los <i>blueprints</i> son más lentos que C++ </p> </blockquote> </section> <section id="slide-org1d81c08"> <h3 id="org1d81c08">Eficiencia del desarrollo</h3> <p> La eficiencia no está sólo en la ejecución, sino también en la velocidad a la que se crea el juego </p> </section> <section> <p> Con <i>blueprints</i>, en general, se llega antes a un prototipo jugable </p> </section> <section> <p> No hay que despreciar el tiempo de ciclo de prueba-compilación en C++ </p> <p> Es alto, por el tipo de construcción de UE, pero ha mejorado mucho en cada versión </p> </section> <section id="slide-org5baf6cd"> <h3 id="org5baf6cd">Cómo usar C++ rápido</h3> <ul> <li>Experimentar/prototipar en <i>blueprints</i></li> <li>No cambiéis los <code>.h</code> a menudo</li> <li>Añadid mucho código antes de compilar</li> <li>Usad algo mejor que "Intellisense" (Visual Assist, por ejemplo)</li> </ul> </section> </section> <section> <section id="slide-org36ebdd0"> <h2 id="org36ebdd0">Ampliaciones</h2> </section> <section> <ul> <li>Implementar todo el ejemplo que se ha puesto</li> <li>Que se cree un texto en pantalla (no con un <code>print</code>, sino con un <i>billboard</i>) indicando qué hay que hacer</li> <li>Hacer que la celda se suba con un <i>timeline</i> como respuesta al evento de antes de terminar</li> </ul> </section> </section> </div> </div> <script src="/clase1.reveal.372e8951.js"></script> <script src="/clase1.reveal.e41122ab.js"></script> <script src="/clase1.reveal.a11129a9.js"></script> <script src="/clase1.reveal.167eb7a6.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!0,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"none",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>