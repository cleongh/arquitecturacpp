<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><title>Trabajar con blueprints visuales y C++</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="clase2.reveal.18d13a9f.css"><link rel="stylesheet" href="clase2.reveal.1c90f13b.css" id="theme"><link rel="stylesheet" href="clase2.reveal.414f56ec.css"><link rel="stylesheet" href="clase2.reveal.906222cb.css"></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Trabajar con blueprints visuales y C++</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2> </section> <section> <section id="slide-org4c3a4a9"> <h2 id="org4c3a4a9">¿BP o C++?</h2> <div class="outline-text-2" id="text-org4c3a4a9"> </div> </section> <section id="slide-orgc1e1d7c"> <h3 id="orgc1e1d7c">¿Por qué usar Blueprint visuales?</h3> </section> <section> <p> En C++ es más sencillo (y en ocasiones más eficiente) hacer ciertos comportamientos (como cálculos matemáticos complejos) </p> </section> <section> <p> Sin embargo, hay algunos comportamientos que se programan muy fácilmente de modo gráfico </p> </section> <section id="slide-org835b9b4"> <h3 id="org835b9b4">Componentes como bloques Blueprint visuales</h3> </section> <section> <p> Vamos a crear un actor+componente que sea un trigger y se active justo delante de la celda, sólo si tenemos los puntos suficientes </p> <p> El <code>Actor</code> puede ser en Blueprints o en C++ </p> </section> <section> <p> Cuando solape con ese actor, lanzará un evento </p> </section> <section> <p> Ahora, <i>en el componente</i>, añadimos (por encima de <code>UCLASS(ClassGroup</code>&#x2026;))=) el siguiente código: </p> <div class="org-src-container"> <pre><code class="cpp">DECLARE_DYNAMIC_MULTICAST_DELEGATE()
</code></pre> </div> </section> <section> <p> Un <a href="https://docs.unrealengine.com/latest/en-US/delegates-and-lamba-functions-in-unreal-engine/"><i>delegate</i></a> es una estructura que encapsula una llamada a función </p> <p> Se usan para conectar <i>blueprints</i> con C++ </p> </section> <section> <p> <code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code> es necesario si queremos que haya una propiedad del componente que podamos asignar en un Blueprint </p> <ul> <li><code>DYNAMIC</code>: puede ser serializado</li> <li><code>MULTICAST</code>: de uno a muchos</li> <li><code>DELEGATE</code>: algo externo va a manejar la operación</li> </ul> </section> <section> <p> Ahora creamos el código: </p> <div class="org-src-container"> <pre><code class="cpp">// hay muchas macros en las que ';' es opcional
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FAntesTerminar); 
</code></pre> </div> <p> (Recordemos que <code>F</code> al principio de la clase se usa por convenio en Unreal) </p> <p> Esto crea una clase propia para la señal en el editor de Blueprints </p> </section> <section> <p> Después, en los atributos privados, creemos un <code>UPROPERTY</code> con el param de esa clase que hemos referenciado en <code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code> </p> </section> <section> <p> Esta propiedad tiene que ser <code>BlueprintAssignable</code>: <a href="https://docs.unrealengine.com/latest/en-US/exposing-gameplay-elements-to-blueprints-visual-scripting-in-unreal-engine/"><code>UPROPERTY(BlueprintAssignable)</code></a> para que se vea en el editor: </p> <div class="org-src-container"> <pre><code class="cpp">UPROPERTY(BlueprintAssignable)
FAntesTerminar AntesTerminar;
</code></pre> </div> </section> <section> <p> Bien, ahora hemos creado un <i>evento</i> </p> </section> <section> <p> Para ello, cuando detectemos solape con la gema, vamos a hacer <code>Broadcast</code> sobre el evento: </p> <div class="org-src-container"> <pre><code class="cpp">AntesTerminar.Broadcast();
</code></pre> </div> </section> <section> <p> Si hemos hecho el actor en C++ tenemos que añadir el componente al actor de nuestro trigger con <code>CreateDefaultSubobject</code> </p> <p> Si está en Blueprint, directamente en el editor </p> <p> Añadimos también, en el <code>Actor</code>, un <code>Box</code> de colisión para establecer el volumen </p> </section> <section> <p> Si el <code>Actor</code> está en C++, el componente tendrá que ser <code>BlueprintReadWrite</code> porque queremos acceder a él desde el editor de <i>blueprints</i>: </p> <div class="org-src-container"> <pre><code class="cpp">public:
  UPROPERTY(EditAnywhere, BlueprintReadWrite)
  UComponenteAntesTerminar * _antesTerminar;
</code></pre> </div> <aside class="notes"> <p> Tenía puesto que tenía que ser "public" en la clase, pero no lo tengo muy claro </p> </aside> </section> <section> <p> Ahora vamos al Blueprint del actor que contiene el componente y en los eventos añadimos el nuevo evento que ha aparecido: </p> <div id="org4366bf8" class="figure"> <p><img src="evento_aparece_en_bp.d99baa57.png" alt="evento_aparece_en_bp.png" height="450"> </p> <p><span class="figure-number">Figura 1: </span>Aparecerá un botón nuevo en los eventos, pinchando en el componente</p> </div> </section> <section> <div id="org34c4639" class="figure"> <p><img src="usar_delegate_bp.e3a1466b.png" alt="usar_delegate_bp.png" height="500"> </p> <p><span class="figure-number">Figura 2: </span>Y este evento lo podemos usar en el <i>blueprint</i> como queramos</p> </div> </section> </section> <section> <section id="slide-org9f893c8"> <h2 id="org9f893c8">Funciones desde C++</h2> </section> <section> <p> Hasta ahora nos hemos centrado en usar C++ como una alternativa a <i>blueprints</i>, pero realmente se complementan muy bien </p> </section> <section> <p> Vamos a ver cómo llamar a funciones C++ desde <i>blueprints</i>, y a funciones <i>blueprint</i> desde C++ </p> </section> </section> <section> <section id="slide-org6e0bd18"> <h2 id="org6e0bd18">Llamar a funciones desde el editor</h2> </section> <section> <p> En el <code>.h</code> de un <code>Actor</code> nuevo, añadimos el prototipo de una función sencilla: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
void SaySomething(const FText &amp; text);
</code></pre> </div> </section> <section> <p> Que implementamos así: </p> <div class="org-src-container"> <pre><code class="cpp">void AActorFuncionLlamable::SaySomething(const FText &amp;text)
{
    FString str = text.ToString();
    UE_LOG(LogTemp, Warning, TEXT("%s"), *str)
}
</code></pre> </div> <aside class="notes"> <p> Puedes recordarles que <code>FText</code> es lo suyo para cadenas localizadas </p> </aside> </section> <section> <p> Las <code>UFUNCTION</code> usan los parámetros como entrada, a no ser que sean como referencia no constante, caso en el cual los usan como salida: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
int32 fun(int32 &amp; output);
</code></pre> </div> </section> <section> <p> Para hacer que esos parámetros no sean de salida, usamos la macro <code>UPARAM</code>, con el argumento <code>ref</code> </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
int32 fun(
    UPARAM(ref) int32 &amp; output
    );
</code></pre> </div> </section> <section> <p> También podemos cambiar la etiqueta de la variable: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
int32 fun(
    UPARAM(DisplayName="Total weight") int32 &amp; output
    );
</code></pre> </div> </section> <section> <p> Para alimentar la función, podemos construir el siguiente esquema en el <i>blueprint</i> del nivel: </p> <div id="orged193b7" class="figure"> <p><img src="bp_llama_cpp.be85b376.png" alt="bp_llama_cpp.png" height="450"> </p> <p><span class="figure-number">Figura 3: </span>Blueprint para establecer variable</p> </div> </section> <section> <p> Podemos establecer diferentes tipos de <code>UFUNCTION</code>, de forma que si queremos una función constante/pura (sin "pestañas" de orden de ejecución en los <i>blueprints</i>, porque no tiene <i>side-effects</i>): </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintCallable)
float CalculoSinEfectos() const;
</code></pre> </div> </section> </section> <section> <section id="slide-org9aa5e1c"> <h2 id="org9aa5e1c">Llamar a funciones <i>blueprint</i> desde C++</h2> </section> <section> <p> <a href="https://docs.unrealengine.com/latest/en-US/API/Runtime/CoreUObject/UObject/UObject/CallFunctionByNameWithArguments/"><code>UObject</code></a> tiene el método <code>CallFunctionByNameWithArguments</code> </p> <p> Con este método podemos acceder a una función en <i>blueprints</i> </p> </section> <section> <p> Vamos a crear un componente <i>blueprint</i> en el editor (es decir, <b>que no sea C++</b>) </p> <p> En él, creamos una función que imprima un texto por pantalla </p> </section> <section> <div id="org942180d" class="figure"> <p><img src="funcion_bp_llamable.f2f117b7.png" alt="funcion_bp_llamable.png" height="450"> </p> <p><span class="figure-number">Figura 4: </span>Función con un parámetro <code>Text</code> que imprime la entrada</p> </div> </section> <section> <p> Ahora creamos un <code>Actor</code> en C++, y en algún sitio (<code>Tick</code>, <code>BeginPlay</code>): </p> <div class="org-src-container"> <pre><code class="cpp">#include "Misc/OutputDeviceNull.h"

// UImprimidorPadreCPP no existe aún
auto f = FindComponentByClass&lt;UImprimidorPadreCPP&gt;();
if (nullptr != f)
{
    // puede ser este null ahora
    FOutputDeviceNull n;

    f-&gt;CallFunctionByNameWithArguments(
        TEXT("Saludar \"hola a todos\""),
        n,  // dispositivo de salida
        nullptr, // ejecutor (null vale)
        true); // forzar llamada (T vale)
}
</code></pre> </div> </section> <section> <p> En efecto, <i>no compila</i> </p> </section> <section> <p> Lo que ocurre es que necesitamos que la clase a la que estamos haciendo referencia <i>exista en C++</i> </p> </section> <section> <p> Vamos a crear una nueva clase en C++ que sea <i>padre</i> de la clase que queremos, para así poder importarla (<code>#include</code>) </p> </section> <section> <p> Creamos una clase <code>Actor</code> de C++ </p> <p> Nos aseguramos de que su <code>UCLASS</code> sea <code>Blueprintable</code> </p> </section> <section> <div class="org-src-container"> <pre><code class="cpp">UCLASS( Blueprintable, ...)
</code></pre> </div> </section> <section> <p> Asegurémonos de que todo compila correctamente </p> </section> <section> <p> Ahora volvemos a nuestra clase <i>blueprint</i> original, y cambiamos el padre: </p> <div id="org8ccb1df" class="figure"> <p><img src="reparent_class.1c6c684e.png" alt="reparent_class.png" height="350"> </p> <p><span class="figure-number">Figura 5: </span>Cambiar el padre de una clase</p> </div> </section> <section> <p> Ahora ya podemos <i>incluir</i> la clase <b>padre</b> en nuestro <code>ActorQueLlamaBP</code> </p> <div class="org-src-container"> <pre><code class="cpp">#include "ImprimidorPadreCPP.h"
</code></pre> </div> <aside class="notes"> <p> recálcales que es la <b>clase padre</b> sólo, pero que eso funciona porque la llamada no necesita tipos </p> </aside> </section> <section> <p> Y probamos: </p> <div class="org-src-container"> <pre><code class="cpp">#include "Misc/OutputDeviceNull.h"

// Si el BP se llama 'UImprimidorPadreCPP', y la función "Saludar"
auto f = FindComponentByClass&lt;UImprimidorPadreCPP&gt;();
if (nullptr != f) // comprobad siempre
  {
    FOutputDeviceNull n;
    FString param = "\"hola a todos!\" 6";
    FString cmd =
      FString::Printf(
		      TEXT("Saludar %s"),
		      *param);

    // Debe imprimir "hola a todos!" y "7" en pantalla
    f-&gt;CallFunctionByNameWithArguments(
       *cmd, n, nullptr, true);
  }
</code></pre> </div> </section> <section> <div id="org2736337" class="figure"> <p><img src="salida_bp_desde_cpp.7553f5fb.png" alt="salida_bp_desde_cpp.png" height="400"> </p> <p><span class="figure-number">Figura 6: </span>Ejemplo de salida llamado a una función <i>blueprint</i> desde C++</p> </div> </section> </section> <section> <section id="slide-orgb93d61b"> <h2 id="orgb93d61b">Más maneras de interactuar BP/C++</h2> <div class="outline-text-2" id="text-orgb93d61b"> </div> </section> <section id="slide-org25acc1c"> <h3 id="org25acc1c"><code>BlueprintImplementableEvent</code></h3> <p> Podemos declarar una función en C++, y la implementamos en una clase hija en <i>blueprint</i>: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintImplementableEvent)
void EventoBP(); // sin implementación!
</code></pre> </div> <p> Y puedo llamar a <code>EventoBP</code> desde cualquier parte de C++ </p> </section> <section> <div id="org7f4049c" class="figure"> <p><img src="implementable_event_bp.790f494d.png" alt="implementable_event_bp.png" height="500"> </p> <p><span class="figure-number">Figura 7: </span>Desde la clase BP que hereda de la clase C++ que tiene <code>EventoBP</code>, sobreescribimos el método</p> </div> </section> <section> <p> Sin parámetros ni salida (<code>void</code>) aparecerá como un evento (si no, como una función) </p> </section> <section id="slide-org791f138"> <h3 id="org791f138"><code>BlueprintNativeEvent</code></h3> <p> Es lo mismo que <code>BlueprintImplementableEvent</code>, pero nos permite dar una implementación nativa por defecto: </p> <div class="org-src-container"> <pre><code class="cpp">UFUNCTION(BlueprintNativeEvent)
void EventoBP();

// ...

void AMiActor::EventoBP_Implementation()
{
  // Implementación por defecto
}
</code></pre> </div> </section> <section> <div id="org4c0111d" class="figure"> <p><img src="recibir_evento_native_bp.3a9eeb3d.png" alt="recibir_evento_native_bp.png" height="500"> </p> <p><span class="figure-number">Figura 8: </span>Podemos llamar a la implementación del padre (en C++) también</p> </div> </section> </section> <section> <section id="slide-org3253479"> <h2 id="org3253479">Cosas que los <i>blueprints</i> no pueden hacer</h2> </section> <section> <p> Se puede llegar muy lejos con <i>blueprints</i> </p> <p> Pero hay algunas cosas que necesitan C++ </p> </section> <section id="slide-orgf35fa4c"> <h3 id="orgf35fa4c">Importar librerías externas</h3> <p> Para código existente (en C++ u otros lenguajes), hay que usar C++ </p> </section> <section id="slide-org13eff44"> <h3 id="org13eff44">Colaborar a nivel de módulo</h3> <p> Los <i>blueprints</i> son archivos binarios, es difícil ponerlos en control de versiones y trabajar por partes en paralelo </p> </section> <section id="slide-org5c7c5e6"> <h3 id="org5c7c5e6">Algunas cosas se expresan mejor en C++</h3> <p> Los <i>blueprints</i> están pensado para lógica de juego, no para algoritmos complejos y genéricos </p> <p> Muchas veces, el código C++ será más fácil de mantener que un script visual de <i>blueprints</i> muy complejo </p> </section> </section> <section> <section id="slide-org2a74b23"> <h2 id="org2a74b23">Eficiencia <i>blueprints</i> y eficiencia C++</h2> <blockquote> <p> Los <i>blueprints</i> son más lentos que C++ </p> </blockquote> </section> <section id="slide-orgd514bb4"> <h3 id="orgd514bb4">Eficiencia del desarrollo</h3> <p> La eficiencia no está sólo en la ejecución, sino también en la velocidad a la que se crea el juego </p> </section> <section> <p> Con <i>blueprints</i>, en general, se llega antes a un prototipo jugable </p> </section> <section> <p> No hay que despreciar el tiempo de ciclo de prueba-compilación en C++ </p> <p> Es alto, por el tipo de construcción de UE, pero ha mejorado mucho en cada versión </p> </section> <section id="slide-org74b1e98"> <h3 id="org74b1e98">Cómo usar C++ rápido</h3> <ul> <li>Experimentar/prototipar en <i>blueprints</i></li> <li>No cambiéis los <code>.h</code> a menudo</li> <li>Añadid mucho código antes de compilar</li> <li>Usad algo mejor que "Intellisense" (Visual Assist, por ejemplo)</li> </ul> </section> </section> <section> <section id="slide-org1e68876"> <h2 id="org1e68876">Ampliaciones</h2> </section> <section> <ul> <li>Implementar todo el ejemplo que se ha puesto</li> <li>Que se cree un texto en pantalla (no con un <code>print</code>, sino con un <i>billboard</i>) indicando qué hay que hacer</li> <li>Hacer que la celda se suba con un <i>timeline</i> como respuesta al evento de antes de terminar</li> </ul> </section> </section> </div> </div> <script src="clase2.reveal.b569981f.js"></script> <script src="clase2.reveal.a5a6b0e0.js"></script> <script src="clase2.reveal.8f5a3bfe.js"></script> <script src="clase2.reveal.85129afe.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!0,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"none",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>